---
title: "Simulation Study for Three-Level Mixed Effect Model with Two Autoregressive Processes"
author: "Tzu-Yao Lin"
date: last-modified
bibliography: references.bib
csl: apa.csl
execute:
  eval: false
  warning: false
  cache: false
format: 
  html:
    toc: true
    toc-depth: 3
    number-sections: true
    self-contained: true
    code-fold: false
    code-tools: true
    include-in-header: mathjax.html
---

# Setup

First, we need to load the necessary packages.

```{r}
#| label: load-packages

library(tidyverse)
theme_set(theme_bw(base_size = 14))
library(lubridate)
library(tsibble)
library(cmdstanr)
register_knitr_engine(override = FALSE)
library(posterior)
library(bayesplot)
color_scheme_set("blue")
```

# Generate Data and Fitting by Stan

Check the file `run_sim_3l-lmm_ARdHdARmHm.R1`.


# Check Results

```{r}
model_name <- "sim_3l-lmm_ARdHdARmHm"

data <- read_rds(str_glue("data/{model_name}.rds"))
names(data)
N <- data$N
D <- data$D
M <- data$M
```

```{r}
#| label: load-MCMC

lmm_fit <- as_cmdstan_fit(list.files(str_glue("stan/draws/{model_name}"), full.names = TRUE))
```

All 4 chains finished successfully.
Mean chain execution time: 2619.6 seconds.
Total execution time: 3757.2 seconds.

Warning: 1 of 4 chains had an E-BFMI less than 0.3.
See https://mc-stan.org/misc/warnings for details.


Check the summary results in `stan/summary/sim_3l-lmm_ARdHdARmHm.csv`


```{r}
lmm_draws <- lmm_fit$draws(format = "matrix")
```

Following, I want to check the 95% HDI of the posterior distribution whether it contains the true parameter setting values. I would misus a handy function `bayesplot:ppc_XX()` on purpose to check the results, but it does not mean I'm doing the posterior predictive check.

[1] "N"             "D"             "M"             "psi_s"         "s"            
 [6] "psi_d"         "d"             "phi_d"         "H_d"           "sigma_omega_d"
[11] "tau2_d"        "Sigma_d"       "nu"            "phi_m"         "H_m"          
[16] "sigma_omega_m" "tau2_m"        "Sigma_m"       "omega"         "sigma_epsilon"
[21] "epsilon"       "y"        

```{r}
order_s <- order(data$s)
ppc_intervals(y = data$s[order_s], 
              yrep = subset_draws(lmm_draws, variable = str_glue("s[{order_s}]"))) + 
  scale_x_discrete(name = "Subject effect (s)") 

```


```{r}
order_d <- order(data$d)
index_row <- (order_d-1) %% N + 1
index_col <- (order_d-1) %/% N + 1

ppc_intervals(y = data$d[order_d], 
              yrep = subset_draws(lmm_draws, variable = str_glue("d[{index_row},{index_col}]"))) + 
  scale_x_discrete(name = "Day effect (d)")
```


```{r}
pars_phi <- c("phi_d", "phi_m")
ppc_intervals(y = data[pars_phi] |> unlist(), 
              yrep = subset_draws(lmm_draws, variable = pars_phi)) + 
  scale_x_discrete(name = "Autocorrelation effects", 
                   limit = pars_phi)
```


```{r}
pars_sd <- c("psi_s", "psi_d", "sigma_omega_d", "sigma_omega_m", "sigma_epsilon")
ppc_intervals(y = data[pars_sd] |> unlist(), 
              yrep = subset_draws(lmm_draws, variable = pars_sd)) + 
  scale_x_discrete(name = "Standard deviations", 
                   limits = c("psi_s", str_glue("psi_d[{j}]", j = 1:9), "sigma_omega_d", "sigma_omega_m", str_glue("sigma_epsilon[{k}]", k = 1:10)))
```


```{r}
pars_tau <- c("tau2_d", "tau2_m")
ppc_intervals(y = data[pars_tau] |> unlist(), 
              yrep = subset_draws(lmm_draws, variable = pars_tau)) + 
  scale_x_discrete(name = "Variances for AR(1) for day and moment levels", 
                   limits = pars_tau)
```

```{r}
attach(data)

rel_T = (psi_s^2 + mean(psi_d^2)) / (psi_s^2 + mean(psi_d^2) + tau2_d + tau2_m + mean(sigma_epsilon^2))
ppc_intervals(y = rel_T, 
              yrep = subset_draws(lmm_draws, variable = "rel_T")) + 
  scale_x_discrete(name = "R_T")
```


```{r}
data$y
data_df <- expand.grid(Moment = 1:10, Day = 1:9, Subject = 1:100) |> 
  add_column(y = data$y)


.y_hat_summary_lmm <- lmm_fit$summary("y_hat", mean, median, quantile2) 

y_hat_summary_lmm <- .y_hat_summary_lmm |> 
  mutate(Indices = str_extract_all(variable, "\\d+"), 
         Participant = map_dbl(Indices, \(x) as.integer(x[1])),
         Day = map_dbl(Indices, \(x) as.integer(x[2])),
         Moment = map_dbl(Indices, \(x) as.integer(x[3])))

data_predict_lmm <- data |> 
  left_join(y_hat_summary_lmm)

data_predict_lmm |> 
  filter(Participant %in% selected_subj) |> 
  mutate(Date_time = as_datetime(days(Day) + Time)) |> 
  ggplot(aes(x = Date_time, y = Neg_aff)) + 
  geom_line() + geom_point() +
  geom_line(aes(y = mean), linetype = "dashed") +
  geom_ribbon(aes(ymin = q5, ymax = q95), alpha = 0.25) +
  coord_cartesian(ylim = c(-20, 100)) +
  scale_x_datetime(breaks = as_datetime(1:9 * 86400),
                   labels = paste("Day", 1:9)) +
  facet_grid(Participant ~ .) 

```